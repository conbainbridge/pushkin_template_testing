"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _axios = _interopRequireDefault(require("axios"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Pushkin =
/*#__PURE__*/
function () {
  function Pushkin() {
    _classCallCheck(this, Pushkin);

    this.con = undefined;
  }

  _createClass(Pushkin, [{
    key: "connect",
    value: function connect(quizAPIUrl) {
      this.con = _axios["default"].create({
        baseURL: quizAPIUrl
      });
    }
  }, {
    key: "loadScript",
    value: function loadScript(url) {
      return new Promise(function (resolve, reject) {
        var timeout = setTimeout(function () {
          return reject("Loading timed out for ".concat(url));
        }, 5000); // check if this script is already loaded and reload if it is
        // can't use array 'has' because getElements doesn't return an array

        var scripts = document.getElementsByTagName('script');

        for (var i = 0; i < scripts.length; i++) {
          if (scripts[i].src == url) scripts[i].parentNode.removeChild(scripts[i]);
        }

        var script = document.createElement('script');

        script.onload = function () {
          clearTimeout(timeout);
          resolve(script);
        };

        script.src = url;
        document.body.appendChild(script);
      });
    }
  }, {
    key: "loadScripts",
    value: function loadScripts(urls) {
      return Promise.all(urls.map(this.loadScript));
    }
  }, {
    key: "tabulateAndPostResults",
    value: function tabulateAndPostResults(userID, experiment) {
      var postData = {
        user_id: userID,
        experiment: experiment
      };
      return this.con.post('/tabulateAndPostResults', postData);
    }
  }, {
    key: "prepExperimentRun",
    value: function prepExperimentRun(userID) {
      var postData = {
        user_id: userID
      };
      return this.con.post('/startExperiment', postData);
    }
  }, {
    key: "getAllStimuli",
    value: function getAllStimuli(userID, nItems) {
      var postData = {
        user_id: userID,
        nItems: nItems
      };
      return this.con.post('/getStimuli', postData).then(function (res) {
        var stimuli = res.data.resData;
        return stimuli.map(function (s) {
          return JSON.parse(s.stimulus);
        });
      });
    }
  }, {
    key: "setSaveAfterEachStimulus",
    value: function setSaveAfterEachStimulus(stimuli) {
      var _this = this;

      return stimuli.map(function (s) {
        return _objectSpread({}, s, {
          on_finish: _this.saveStimulusResponse.bind(_this)
        });
      });
    }
  }, {
    key: "saveStimulusResponse",
    value: function saveStimulusResponse(data) {
      // Because we are saving data, it should be coming with a userID already
      // Might make sense at some point to confirm this is what we expect
      var stimulus;

      try {
        stimulus = data.stimulus;
      } catch (e) {
        throw new Error('jsPsych data does not include a stimulus key');
      }

      var user_id;

      try {
        user_id = data.user_id;
      } catch (e) {
        throw new Error('req does not include a user_id');
      }

      var postData = {
        user_id: user_id,
        data_string: data,
        stimulus: stimulus
      };
      return this.con.post('/stimulusResponse', postData);
    }
  }, {
    key: "insertMetaResponse",
    value: function insertMetaResponse(data) {
      var metaQuestion;

      try {
        metaQuestion = data.stimulus;
      } catch (e) {
        throw new Error('jsPsych data does not include a stimulus key');
      }

      var user_id;

      try {
        user_id = data.user_id;
      } catch (e) {
        throw new Error('req does not include a user_id');
      }

      var postData = {
        user_id: user_id,
        data_string: data,
        stimulus: stimulus
      };
      return this.con.post('/insertMetaResponse', postData);
    }
  }, {
    key: "endExperiment",
    value: function endExperiment(userID) {
      var postData = {
        user_id: userID
      };
      return this.con.post('/endExperiment', postData);
    }
  }, {
    key: "customApiCall",
    value: function customApiCall(path, data, httpMethod) {
      var _this2 = this;

      httpMethod = httpMethod || 'post';
      return new Promise(function (resolve, reject) {
        _this2.con[httpMethod](path, data).then(function (response) {
          // parse it if it's JSON, leave it otherwise
          try {
            response = JSON.parse(response);
          } catch (e) {}

          var resData = response.data && response.data.resData ? response.data.resData : null;
          resolve(resData);
        })["catch"](function (err) {
          reject(err);
        });
      });
    }
  }]);

  return Pushkin;
}();

exports["default"] = Pushkin;