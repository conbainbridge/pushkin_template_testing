"use strict";

require("core-js/stable");

require("regenerator-runtime/runtime");

var _amqplib = _interopRequireDefault(require("amqplib"));

var _knex = _interopRequireDefault(require("knex"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var trim = function trim(s, len) {
  return s.length > len ? s.substring(0, len) : s;
};

var PushkinWorker =
/*#__PURE__*/
function () {
  function PushkinWorker(options) {
    _classCallCheck(this, PushkinWorker);

    this.amqpAddress = options.amqpAddress;
    this.readQueue = options.readQueue;
    this.writeQueue = options.writeQueue;
    this.taskQueue = options.taskQueue;
    this.conn = undefined;
    this.initialized = false;
    this.handlers = new Map();
  }

  _createClass(PushkinWorker, [{
    key: "init",
    value: function init() {
      var _this = this;

      return regeneratorRuntime.async(function init$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                _amqplib["default"].connect(_this.amqpAddress).then(function (conn) {
                  _this.conn = conn;
                  _this.initialized = true;
                  console.log('Worker connected to message queue');
                  resolve();
                })["catch"](function (err) {
                  reject("Error connecting to message queue: ".concat(err));
                });
              }));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      });
    }
  }, {
    key: "handle",
    value: function handle(method, handler) {
      console.log("handling ".concat(method, " with ").concat(handler));
      this.handlers.set(method, handler);
    } // useDefaultHandles(dbUrl, dbTablePrefix, transactionOps) {
    // 	const handler = new defaultHandler(dbUrl, dbTablePrefix, transactionOps);
    // 	defaultMethods.forEach(h => {
    // 		this.handle(h, handler[h].bind(handler));
    // 	});
    // }

  }, {
    key: "useHandler",
    value: function useHandler(ahandler, dbUrl, dbTablePrefix, transactionOps) {
      var _this2 = this;

      var handler = new ahandler(dbUrl, dbTablePrefix, transactionOps);
      var methods = handler.methods();
      methods.forEach(function (h) {
        _this2.handle(h, handler[h].bind(handler));
      });
    }
  }, {
    key: "start",
    value: function start() {
      var _this3 = this;

      this.conn.createChannel().then(function (ch) {
        ch.assertQueue(_this3.readQueue, {
          durable: false
        });
        ch.assertQueue(_this3.writeQueue, {
          durable: true
        });
        ch.assertQueue(_this3.taskQueue, {
          durable: false
        });
        ch.prefetch(1);

        var consumeCallback = function consumeCallback(msg) {
          console.log("got message: ".concat(msg.content.toString()));
          Promise.resolve(msg.content.toString()).then(JSON.parse).then(function (req) {
            if (!req || !req.method || req.data === undefined) throw new Error('requests must have a method and data field'); // try to call a handler

            if (!_this3.handlers.has(req.method)) throw new Error("no handler found to handle method ".concat(req.method));
            var sessId = req.sessionId;
            return _this3.handlers.get(req.method)(sessId, req.data, req.params);
          }).then(function (res) {
            console.log("responding ".concat(res));
            ch.sendToQueue(msg.properties.replyTo, new Buffer.from(JSON.stringify(res)), {
              correlationId: msg.properties.correlationId
            });
            ch.ack(msg);
          })["catch"](function (err) {
            console.error(err);
            ch.ack(msg);
            ch.sendToQueue(msg.properties.replyTo, new Buffer.from(JSON.stringify(err)), {
              correlationId: msg.properties.correlationId
            });
          });
        };

        console.log("consuming on ".concat(_this3.readQueue));
        ch.consume(_this3.readQueue, consumeCallback);
        console.log("consuming on ".concat(_this3.writeQueue));
        ch.consume(_this3.writeQueue, consumeCallback);
        console.log("consuming on ".concat(_this3.taskQueue));
        ch.consume(_this3.taskQueue, consumeCallback);
      })["catch"](function (err) {
        console.error("failed to created channel: ".concat(err));
      });
    }
  }]);

  return PushkinWorker;
}(); // helper function for turning string *or* JSON into string


function handleJSON(str) {
  try {
    JSON.parse(str);
  } catch (e) {
    return str;
  }

  return JSON.stringify(str);
}

var DefaultHandler =
/*#__PURE__*/
function () {
  function DefaultHandler(db_url, dbTablePrefix, transactionOps) {
    _classCallCheck(this, DefaultHandler);

    this.tables = {
      users: "pushkin_users",
      userResults: "pushkin_userResults",
      userMeta: "pushkin_userMeta",
      stim: "".concat(dbTablePrefix, "_stimuli"),
      stimResp: "".concat(dbTablePrefix, "_stimulusResponses"),
      stimGroups: "".concat(dbTablePrefix, "_stimulusGroups"),
      stimGroupStim: "".concat(dbTablePrefix, "_stimulusGroupStimuli")
    };
    this.pg_main = (0, _knex["default"])({
      client: 'pg',
      connection: db_url
    });
    this.logging = transactionOps ? true : false;

    if (this.logging) {
      this.trans_table = transactionOps.tableName;
      this.pg_trans = (0, _knex["default"])({
        client: 'pg',
        connection: transactionOps.url
      });
      this.trans_mapper = transactionOps.mapper;
    }
  }

  _createClass(DefaultHandler, [{
    key: "logTransaction",
    value: function logTransaction(knexCommand) {
      var toInsert;
      return regeneratorRuntime.async(function logTransaction$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (this.logging) {
                _context2.next = 2;
                break;
              }

              return _context2.abrupt("return", knexCommand);

            case 2:
              toInsert = this.trans_mapper(knexCommand.toString());
              _context2.next = 5;
              return regeneratorRuntime.awrap(this.pg_trans(this.trans_table).insert(toInsert));

            case 5:
              return _context2.abrupt("return", knexCommand);

            case 6:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "tabulateAndPostResults",
    value: function tabulateAndPostResults(sessId, data) {
      var results;
      return regeneratorRuntime.async(function tabulateAndPostResults$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (sessId) {
                _context3.next = 2;
                break;
              }

              throw new Error('startExperiment got invalid session id');

            case 2:
              if (data.user_id) {
                _context3.next = 4;
                break;
              }

              throw new Error('startExperiment got invalid userID');

            case 4:
              if (data.experiment) {
                _context3.next = 6;
                break;
              }

              throw new Error('startExperiment got invalid userID');

            case 6:
              results = 'Completed this experiment with flying colors'; //stub

              return _context3.abrupt("return", this.logTransaction(this.pg_main(this.tables.userResults).insert({
                user_id: data.user_id,
                experiment: data.experiment,
                results: results,
                created_at: new Date()
              })));

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "startExperiment",
    value: function startExperiment(sessId, data) {
      var userId, userCount;
      return regeneratorRuntime.async(function startExperiment$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (sessId) {
                _context4.next = 2;
                break;
              }

              throw new Error('startExperiment got invalid session id');

            case 2:
              if (data.user_id) {
                _context4.next = 4;
                break;
              }

              throw new Error('startExperiment got invalid userID');

            case 4:
              userId = data.user_id;
              _context4.next = 7;
              return regeneratorRuntime.awrap(this.pg_main(this.tables.users).where('user_id', userId).count('*'));

            case 7:
              userCount = _context4.sent[0].count;

              if (!(userCount > 0)) {
                _context4.next = 12;
                break;
              }

              return _context4.abrupt("return");

            case 12:
              return _context4.abrupt("return", this.logTransaction(this.pg_main(this.tables.users).insert({
                user_id: data.user_id,
                created_at: new Date()
              })));

            case 13:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "getStimuli",
    value: function getStimuli(sessId, data) {
      var userId, nItems, selectedStims;
      return regeneratorRuntime.async(function getStimuli$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (sessId) {
                _context5.next = 2;
                break;
              }

              throw new Error('getStimuli got invalid session id');

            case 2:
              if (data.user_id) {
                _context5.next = 4;
                break;
              }

              throw new Error('getStimuli got invalid userID');

            case 4:
              userId = data.user_id;
              nItems = data.nItems;

              if (!data.nItems) {
                _context5.next = 12;
                break;
              }

              _context5.next = 9;
              return regeneratorRuntime.awrap(this.pg_main(this.tables.stim).select('stimulus').orderByRaw('random()').limit(nItems));

            case 9:
              _context5.t0 = _context5.sent;
              _context5.next = 15;
              break;

            case 12:
              _context5.next = 14;
              return regeneratorRuntime.awrap(this.pg_main(this.tables.stim).select('stimulus').orderByRaw('random()'));

            case 14:
              _context5.t0 = _context5.sent;

            case 15:
              selectedStims = _context5.t0;
              return _context5.abrupt("return", selectedStims);

            case 17:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "insertStimulusResponse",
    value: function insertStimulusResponse(sessId, data) {
      return regeneratorRuntime.async(function insertStimulusResponse$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              if (sessId) {
                _context6.next = 2;
                break;
              }

              throw new Error('insertStimulusResponse got invalid session id');

            case 2:
              if (data.data_string) {
                _context6.next = 4;
                break;
              }

              throw new Error('insertStimulusResponse got invalid response data string');

            case 4:
              if (data.user_id) {
                _context6.next = 6;
                break;
              }

              throw new Error('insertStimulusResponse got invalid userID');

            case 6:
              if (data.data_string.stimulus) {
                _context6.next = 8;
                break;
              }

              throw new Error('insertStimulusResponse got invalid stimulus');

            case 8:
              console.log("inserting response for user ".concat(data.user_id, ": ").concat(trim(JSON.stringify(data.data_string), 100)));
              return _context6.abrupt("return", this.logTransaction(this.pg_main(this.tables.stimResp).insert({
                user_id: data.user_id,
                stimulus: JSON.stringify(data.data_string.stimulus),
                response: JSON.stringify(data.data_string),
                created_at: new Date()
              })));

            case 10:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "insertMetaResponse",
    value: function insertMetaResponse(sessId, data) {
      return regeneratorRuntime.async(function insertMetaResponse$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              if (sessId) {
                _context7.next = 2;
                break;
              }

              throw new Error('insertStimulusResponse got invalid session id');

            case 2:
              if (data.data_string) {
                _context7.next = 4;
                break;
              }

              throw new Error('insertStimulusResponse got invalid response data string');

            case 4:
              if (data.user_id) {
                _context7.next = 6;
                break;
              }

              throw new Error('insertStimulusResponse got invalid userID');

            case 6:
              if (data.stimulus) {
                _context7.next = 8;
                break;
              }

              throw new Error('insertStimulusResponse got invalid stimulus');

            case 8:
              console.log("inserting meta response for user ".concat(data.user_id, ": ").concat(trim(JSON.stringify(data.data_string), 100)));
              return _context7.abrupt("return", this.logTransaction(this.pg_main(this.tables.userMeta).insert({
                user_id: data.user_id,
                metaQuestion: JSON.stringify(data.stimulus),
                metaResponse: JSON.stringify(data.data_string),
                created_at: new Date()
              })));

            case 10:
            case "end":
              return _context7.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "methods",
    value: function methods() {
      var methods = ['getStimuli', 'insertStimulusResponse', 'startExperiment', 'insertMetaResponse', 'tabulateAndPostResults'];
      return methods;
    }
  }]);

  return DefaultHandler;
}();

module.exports = {
  defaultHandler: DefaultHandler,
  pushkinWorker: PushkinWorker
};